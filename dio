#!/usr/bin/env bash

VERSION=v0.13
API_URL=https://api.digitalocean.com/v2

#--------------------
# LOGGING SECTION
#--------------------

# Black        0;30     Dark Gray     1;30
# Blue         0;34     Light Blue    1;34
# Green        0;32     Light Green   1;32
# Cyan         0;36     Light Cyan    1;36
# Red          0;31     Light Red     1;31
# Purple       0;35     Light Purple  1;35
# Brown/Orange 0;33     Yellow        1;33
# Light Gray   0;37     White         1;37

# MAC has different names
if [[ `uname` == "Darwin" ]]; then
  BLUE='\x1B[0;34m'
  LIGHT_GREY='\x1B[0;37m'
  DARK_RED='\x1B[1;31m'
  LIGHT_RED='\x1B[0;31m'
  LIGHT_GREEN='\x1B[0;32m'
  NC='\x1B[0m' # No Color
else
  BLUE='\e[0;34m'
  LIGHT_GREY='\e[0;37m'
  DARK_RED='\e[1;31m'
  LIGHT_RED='\e[0;31m'
  LIGHT_GREEN='\e[0;32m'
  NC='\e[0m' # No Color
fi

exec 3>&2 # logging stream (file descriptor 3) defaults to STDERR

DEBUG_LEVEL=0
INFO_LEVEL=1
WARNING_LEVEL=2
ERROR_LEVEL=3
FATAL_LEVEL=4

error() { log $ERROR_LEVEL "${DARK_RED}$1${NC}"; }
warn() { log $WARNING_LEVEL "${LIGHT_RED}$1${NC}"; }
notify() { log $INFO_LEVEL "${NC}$1${NC}"; }
info() { log $INFO_LEVEL "${NC}$1${NC}"; }
debug() { log $DEBUG_LEVEL "${LIGHT_GREY}$1${NC}"; }

error_all() { [[ "$1" != "/dev/null" ]] && (tail -n 100 $1 > $1.last ; while read line; do error "$line" ; done < $1.last ;) }
warn_all() { [[ "$1" != "/dev/null" ]] && (tail -n 100 $1 > $1.last ; while read line; do warn "$line" ; done < $1.last ;) }
notify_all() { [[ "$1" != "/dev/null" ]] && (tail -n 100 $1 > $1.last ; while read line; do notify "$line" ; done < $1.last ;) }
debug_all() { [[ "$1" != "/dev/null" ]] && (tail -n 100 $1 > $1.last ; while read line; do debug "$line" ; done < $1.last ;) }

blue() { pp "${BLUE}$1${NC}"; }
grey() { pp "${LIGHT_GREY}$1${NC}"; }
red() { pp "${DARK_RED}$1${NC}"; }
green() { pp "${LIGHT_GREEN}$1${NC}"; }
black() { pp "$1"; }

log() {
  LOGLEVEL=${LOGLEVEL-$INFO_LEVEL}
  if [ "$LOGLEVEL" -le "$1" ] && [ ! -z "$2" ]; then
    pp "$2"
  fi
}

pp() {
  if [[ `uname` == "Darwin" ]]; then
    echo -e "$1" >&3
  else
    # Expand escaped characters, wrap at 70 chars, indent wrapped lines
    echo -e "$1" | sed '2~1s/^/  /' >&3
  fi
}


#--------------------
# INSATLLER
#--------------------

install_digitalocean()
{
  NAME=$1

  mkdir -p $NAME
  (
    cd $NAME && \
    git init && \
    mkdir -p ./bits && \
    touch ./bits/.gitkeep && \
    touch .gitignore && \
    echo "assets" >> .gitignore && \
    echo "nodes" >> .gitignore && \
    git add . && \
    git commit -m "Initial commit"
  )
  (
    cd $NAME && \
    [[ `git ls-remote --quiet bootstrap 2>/dev/null` == "" ]] && \
    git remote add bootstrap https://github.com/digitalocean/digitalocean-bootstrap.git
  )
  (
    cd $NAME && \
    git subtree add --prefix=bits/bootstrap --squash bootstrap master && \
    ./bits/bootstrap/bootstrap
  )
}

internal_version()
{
  cat $1 | grep ^VERSION= | awk -F'=' '{print $2}'
}


usage()
{
  printf "%b" "${BLUE}
=============================
 dio $VERSION A Bash Implementation
 Of the Digital Ocean API

 More information about the API at
 https://developers.digitalocean.com/documentation/v2/
=============================
${NC}

Usage

  ${BLUE}dio${NC} ${LIGHT_GREEN}[action]${NC}

Project Setup

  ${LIGHT_GREEN}init${NC}          ${DARK_GREY}- Initialize the local directory to access a digital ocean account${NC}

API Actions.

  ${LIGHT_GREEN}create${NC}        ${DARK_GREY}- Create a new digitalocean droplet (by NAME)${NC}
  ${LIGHT_GREEN}delete${NC}        ${DARK_GREY}- Delete a new digitalocean droplet (by ID)${NC}

API Queries

  ${LIGHT_GREEN}list keys${NC}     ${DARK_GREY}- List all SSH Keys assoicated with your account${NC}
  ${LIGHT_GREEN}list droplets${NC} ${DARK_GREY}- List all droplets (use this to grab your droplet IDs${NC}
  ${LIGHT_GREEN}info <ID>${NC}     ${DARK_GREY}- List details about your droplet${NC}


Other Actions

  ${LIGHT_GREEN}update-self${NC}   ${DARK_GREY}- Upgrade to latest version${NC}
  ${LIGHT_GREEN}version${NC}       ${DARK_GREY}- Display just version information, like 'dio $VERSION'${NC}
  ${LIGHT_GREEN}help${NC}          ${DARK_GREY}- Show this message${NC}

${LIGHT_GREY}
For reporting issues, please contact aforward@gmail.com, or
report directly against the project at https://github.com/capbash/dio
${NC}
"
}

do_help()
{
  case "$1" in
  "create")
    info "Create a new droplet..."
    ;;
  "list")
    info "Show 'droplets' (default), and 'keys'."
    ;;
  *)
    usage
    ;;
  esac
}

throw () {
  echo "$*" >&2
  exit 1
}

handle_error()
{
  local RETURN_CODE=$1
  local ANSWER="$2"
  local TITLE="$3"
  local LOGFILE=${LOGFILE-/tmp/dio.log}
  if [ $RETURN_CODE -ne 0 ] ; then
    error $TITLE
    OUTPUT=$(process "$ANSWER")
    error "$OUTPUT"
    error_all $LOGFILE
    exit 1
  fi
}

#--------------------
# JSON PARSER
#--------------------

awk_egrep () {
  local pattern_string=$1

  gawk '{
    while ($0) {
      start=match($0, pattern);
      token=substr($0, start, RLENGTH);
      print token;
      $0=substr($0, start+RLENGTH);
    }
  }' pattern="$pattern_string"
}

process()
{
  echo $1 | tokenize | parse
}

tokenize () {
  local GREP
  local ESCAPE
  local CHAR

  if echo "test string" | egrep -ao --color=never "test" &>/dev/null
  then
    GREP='egrep -ao --color=never'
  else
    GREP='egrep -ao'
  fi

  if echo "test string" | egrep -o "test" &>/dev/null
  then
    ESCAPE='(\\[^u[:cntrl:]]|\\u[0-9a-fA-F]{4})'
    CHAR='[^[:cntrl:]"\\]'
  else
    GREP=awk_egrep
    ESCAPE='(\\\\[^u[:cntrl:]]|\\u[0-9a-fA-F]{4})'
    CHAR='[^[:cntrl:]"\\\\]'
  fi

  local STRING="\"$CHAR*($ESCAPE$CHAR*)*\""
  local NUMBER='-?(0|[1-9][0-9]*)([.][0-9]*)?([eE][+-]?[0-9]*)?'
  local KEYWORD='null|false|true'
  local SPACE='[[:space:]]+'

  $GREP "$STRING|$NUMBER|$KEYWORD|$SPACE|." | egrep -v "^$SPACE$"
}

parse_array () {
  local index=0
  local ary=''
  read -r token
  case "$token" in
    ']') ;;
    *)
      while :
      do
        parse_value "$1" "$index"
        index=$((index+1))
        ary="$ary""$value"
        read -r token
        case "$token" in
          ']') break ;;
          ',') ary="$ary," ;;
          *) throw "EXPECTED , or ] GOT ${token:-EOF}" ;;
        esac
        read -r token
      done
      ;;
  esac
  [ "$BRIEF" -eq 0 ] && value=$(printf '[%s]' "$ary") || value=
  :
}

parse_object () {
  local key
  local obj=''
  read -r token
  case "$token" in
    '}') ;;
    *)
      while :
      do
        case "$token" in
          '"'*'"') key=$token ;;
          *) throw "EXPECTED string GOT ${token:-EOF}" ;;
        esac
        read -r token
        case "$token" in
          ':') ;;
          *) throw "EXPECTED : GOT ${token:-EOF}" ;;
        esac
        read -r token
        parse_value "$1" "$key"
        obj="$obj$key:$value"
        read -r token
        case "$token" in
          '}') break ;;
          ',') obj="$obj," ;;
          *) throw "EXPECTED , or } GOT ${token:-EOF}" ;;
        esac
        read -r token
      done
    ;;
  esac
  [ "$BRIEF" -eq 0 ] && value=$(printf '{%s}' "$obj") || value=
  :
}

parse_value () {
  local jpath="${1:+$1,}$2" isleaf=0 isempty=0 print=0
  case "$token" in
    '{') parse_object "$jpath" ;;
    '[') parse_array  "$jpath" ;;
    # At this point, the only valid single-character tokens are digits.
    ''|[!0-9]) throw "EXPECTED value GOT ${token:-EOF}" ;;
    *) value=$token
       # if asked, replace solidus ("\/") in json strings with normalized value: "/"
       [ "$NORMALIZE_SOLIDUS" -eq 1 ] && value=${value//\\\//\/}
       isleaf=1
       [ "$value" = '""' ] && isempty=1
       ;;
  esac
  [ "$value" = '' ] && return
  [ "$LEAFONLY" -eq 0 ] && [ "$PRUNE" -eq 0 ] && print=1
  [ "$LEAFONLY" -eq 1 ] && [ "$isleaf" -eq 1 ] && [ $PRUNE -eq 0 ] && print=1
  [ "$LEAFONLY" -eq 0 ] && [ "$PRUNE" -eq 1 ] && [ "$isempty" -eq 0 ] && print=1
  [ "$LEAFONLY" -eq 1 ] && [ "$isleaf" -eq 1 ] && \
    [ $PRUNE -eq 1 ] && [ $isempty -eq 0 ] && print=1
  [ "$print" -eq 1 ] && printf "[%s]\t%s\n" "$jpath" "$value"
  :
}

parse () {
  read -r token
  parse_value
  read -r token
  case "$token" in
    '') ;;
    *) throw "EXPECTED EOF GOT $token" ;;
  esac
}

BRIEF=1
LEAFONLY=1
PRUNE=1
NORMALIZE_SOLIDUS=1


#--------------------
# API CALLS
#--------------------

get_call()
{
  local TOKEN=${TOKEN}
  local LOGFILE=${LOGFILE-/tmp/dio.log}

  local ANSWER=$(curl -X GET $API_URL/$1 \
                 -H "Authorization: Bearer $TOKEN" \
                 -H "Content-Type: application/json" 2> $LOGFILE)
  echo $ANSWER
}

lookup_droplets()
{
  get_call "droplets"
}

lookup_droplet()
{
  get_call "droplets/$1"
}

lookup_keys()
{
  get_call "account/keys"
}

action_create()
{
  TOKEN=${TOKEN}
  NAME=$1
  REGION=${REGION-tor1}
  SIZE=${SIZE-512mb}
  IMAGE=${IMAGE-ubuntu-14-04-x64}
  SSH_KEYS=${SSH_KEYS-""}
  BACKUPS=${BACKUPS-false}
  IPV6=${IPV6-true}
  USER_DATA=${USER_DATA-null}
  PRIVATE_NETWORKING=${PRIVATE_NETWORKING-true}
  LOGFILE=${LOGFILE-/tmp/dio.log}

  do_verify_token $TOKEN

  if [[ "$SSH_KEYS" = "" ]]; then
    SSH_OUTPUT=""
  else
    SSH_OUTPUT="\"ssh_keys\": $SSH_KEYS, "
  fi

  info "Creating a new droplet $NAME ($REGION, $SIZE, $IMAGE)"

  debug "  -- NAME=$NAME"
  debug "  -- REGION=$REGION"
  debug "  -- SIZE=$SIZE"
  debug "  -- IMAGE=$IMAGE"
  debug "  -- SSH_KEYS=$SSH_KEYS"
  debug "  -- BACKUPS=$BACKUPS"
  debug "  -- IPV6=$IPV6"
  debug "  -- USER_DATA=$USER_DATA"
  debug "  -- PRIVATE_NETWORKING=$PRIVATE_NETWORKING"
  ANSWER=$(curl -X POST $API_URL/droplets \
           -d "{\"name\":\"$NAME\", \"region\":\"$REGION\",\"size\":\"$SIZE\",\"image\":\"$IMAGE\", $SSH_OUTPUT\"backups\": $BACKUPS, \"ipv6\": $IPV6, \"user_data\": $USER_DATA, \"private_networking\": $PRIVATE_NETWORKING}" \
           -H "Authorization: Bearer $TOKEN" \
           -H "Content-Type: application/json" 2> $LOGFILE)

  handle_error $? "$ANSWER" "Unable to create droplet $NAME ($REGION, $SIZE, $IMAGE)"
  OUTPUT=$(process "$ANSWER")
  OUTPUT=$(process "$ANSWER" | grep 'id\|name'  | grep -v 'kernel' | grep -v 'image' | grep -v 'region' | grep -v 'action' | awk -F' ' '{print $2}')

  info "$OUTPUT"
}

action_delete()
{
  local ID=$1
  local TOKEN=${TOKEN}
  local LOGFILE=${LOGFILE-/tmp/dio.log}

  local ANSWER=$(curl -X DELETE $API_URL/droplets/$ID \
                   -H "Authorization: Bearer $TOKEN" \
                   -H "Content-Type: application/json" 2> $LOGFILE)

  echo $ANSWER
}

#--------------------
# TOOL CALLS
#--------------------

read_config()
{
  if [[ -e ".dio" ]]; then
    debug "Reading in configs from .dio"
    . .dio
  else
    debug "No .dio file, skippping"
  fi
}

do_verify_token()
{
  if [[ "$1" = "" ]]; then
    warn "\nWe were unable to find your Digital Ocean TOKEN, PLEASE TAKE ACTION BELOW.\n"
    info "To provide you token you have have a few options...\n"
    info "  1) Create a .dio config file and edit it to contain your token.\n"
    info "     e.g. ${LIGHT_GREEN}dio init${NC}"
    info "          ${LIGHT_GREEN}echo \"TOKEN=983339f14aaaxx94ex6xd89f17797af8f33fd9f39f8ff1xx74397ef83d791787\" >> .dio${NC}\n"
    info "  2) Put your <TOKEN VALUE> in a TOKEN variable"
    info "     e.g. ${LIGHT_GREEN}TOKEN=983339f14aaaxx94ex6xd89f17797af8f33fd9f39f8ff1xx74397ef83d791787 dio list keys${NC}"
    info "\nIf you have no idea what we are talking about, please check out:"
    info "   https://www.digitalocean.com/community/tutorials/how-to-use-the-digitalocean-api-v2"
    info "\nPlease note that 983339f14aaaxx94ex6xd89f17797af8f33fd9f39f8ff1xx74397ef83d791787 is only an example,"
    info "and your token will be much different"
    info "\n"
    exit 1
  fi
}

do_list()
{
  do_verify_token $TOKEN
  ITEM=${1-droplets}
  debug "Looking up $ITEM"
  case "$ITEM" in
  "droplets")
    do_ls_droplets
    ;;
  "keys")
    do_ls_keys
    ;;
  esac
}

do_info()
{
  ID=$1
  ANSWER=$(lookup_droplet $ID)
  handle_error $? "$ANSWER" "Unable to get info about droplet $ID"
  OUTPUT=$(process "$ANSWER")
  notify "$OUTPUT\n"
}

do_ls_droplets()
{
  ANSWER=$(lookup_droplets)
  handle_error $? "$ANSWER" "Unable to list droplets"
  OUTPUT=$(process "$ANSWER" | grep 'id\|name\|status' | grep -v 'kernel' | grep -v 'image' | grep -v 'region' | awk -F' ' '{print $2}')

  notify "\nAvailable Droplets:\n"
  notify "$OUTPUT\n"
}

do_ls_keys()
{
  ANSWER=$(lookup_keys)
  handle_error $? "$ANSWER" "Unable to list keys"
  OUTPUT=$(process "$ANSWER" | grep 'id\|name' | awk -F' ' '{print $2}')

  notify "\nAvailable SSH Keys Include:\n"
  notify "$OUTPUT\n"
}

do_delete()
{
  ID=$1

  ANSWER=$(action_delete $ID)
  handle_error $? "$ANSWER" "Unable to delete droplet $ID"

  if [[ "$ANSWER" != "" ]]; then
    OUTPUT=$(process "$ANSWER")
    warn "\nUnable to delete droplet $ID, official message below..."
    warn "  $ANSWER\n"
  else
    info "\nDeleted a droplet $ID\n"
  fi
}

do_init()
{

  if [[ -e ".dio" ]]; then
    warn "dio already initialized, take a look in .dio"
  else
  info "Initalizing dio..."
printf "%b" "# dio $VERSION
# Provide your Digital Ocean TOKEN
# https://www.digitalocean.com/community/tutorials/how-to-use-the-digitalocean-api-v2
#
# TOKEN=XXXX
#
# You can provide your desired SSH_KEY ID for password login
# https://developers.digitalocean.com/documentation/v2/#ssh-keys
#
# You can get more information about your keys by running
#  > dio list keys
#
# It should be provided as a list, do don't forget your square brackets
# SSH_KEYS=[1234, 4567]
" > ".dio"
  fi

}

#--------------------
# COMMAND LINE PARSER
#--------------------

read_config
case "$1" in
"init")
  do_init
  ;;
"create")
  action_create $2
  ;;
"delete")
  do_delete $2
  ;;
"list")
  do_list $2
  ;;
"info")
  do_info $2
  ;;
"help")
  do_help $2
  ;;
"version")
  echo -e "${BLUE}dio ${VERSION}${NC}"
  exit 0
  ;;
"update-self")
  current_digitalocean_filename=$(which dio)
  OLD_VERSION=$(internal_version $current_digitalocean_filename)
  info "Updating to latest version of dio in ${current_digitalocean_filename}"
  info "When done run '${BLUE}dio version${NC}' for the new version."
  CURLOPT_FRESH_CONNECT=true curl -s -o $current_digitalocean_filename https://raw.githubusercontent.com/capbash/dio/master/dio
  ;;
*)
  usage
  exit 0
  ;;
esac
